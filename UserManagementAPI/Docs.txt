Project Description
This project is a simple RESTful API built using ASP.NET Core. The API allows basic operations on a collection of users.

Code Structure
The project mainly consists of a Program.cs file, which contains all the main logic of the API.

User Class
public class Usuario
{
    public int Id { get; set; }
    public string Nombre { get; set; }
    public string Email { get; set; }
}
This class defines the structure of each user in the system.

Program Class
The Program class contains the main logic of the API:

public class Program
{
    private static List<Usuario> usuarios = new List<Usuario>();
    private static Dictionary<int, Usuario> tempStorage = new Dictionary<int, Usuario>();

    public static async Task<IResult> GetUsers(HttpRequest request)
    {
        // Logic to get users
    }

    public static async Task<IResult> GetUserById(int id)
    {
        // Logic to get a user by ID
    }

    public static async Task<IResult> AddUser(Usuario usuario)
    {
        // Logic to add a new user
    }

    public static async Task<IResult> UpdateUser(int id, Usuario usuarioActualizado)
    {
        // Logic to update an existing user
    }

    public static async Task<IResult> DeleteUser(int id)
    {
        // Logic to delete a user
    }

    public static void Main(string[] args)
    {
        // Initial application setup
    }
}
API Features
Get all users (GET /users)
Get a user by ID (GET /users/{id})
Add a new user (POST /users)
Update an existing user (PUT /users/{id})
Delete a user (DELETE /users/{id})
Notable Features
Use of WebApplication to create the web app.
Implementation of HTTP methods for each CRUD operation.
Use of Results to handle HTTP responses.
Temporary user storage in tempStorage for testing.
Additional Considerations
The project uses an in-memory database instead of a real persistent database.
A temporary storage system (tempStorage) has been implemented to facilitate testing.
The methods are designed to be asynchronous, allowing for better scalability.
This project provides a solid foundation for understanding how a simple RESTful API works in ASP.NET Core and can serve as a starting point for more complex projects.

For error handling, code optimization was requested based on the following instructions:
Please help by adding validations to the existing program for: 
- user input fields when their types do not match or fields are empty.
- Implement try-catch for handling unhandled exceptions.
- Optimize queries or logic to improve performance.

Result:
Documentation of the Optimization and Improvement Process
1. Input Field Validation
Motivation:
Prevent invalid or incomplete data from being entered, which could cause runtime errors or data inconsistencies.

Implementation:

The ValidarUsuario method was created, which checks:
That the user object is not null.
That the Id is positive (when applicable).
That the Name and Email fields are not empty or just spaces.
That the email has a basic valid format (contains @ and has a minimum length).
This method is called in the user creation and update endpoints before processing the request.
2. Exception Handling
Motivation:
Prevent unexpected errors from stopping the API execution and provide clear error messages to the client.

Implementation:

The logic of each endpoint was wrapped in try-catch blocks.
In case of an exception, an appropriate HTTP response (BadRequest or Problem) is returned with the error message.
This ensures that any unhandled error is captured and properly communicated.
3. Query and Logic Optimization
Motivation:
Improve the performance and efficiency of the API, especially in search and update operations.

Implementation:

The list of users (List<Usuario>) was replaced by a dictionary (Dictionary<int, Usuario>), allowing searches, insertions, and deletions in constant time O(1) by key.
The operations to get, update, and delete users now use the dictionary to access directly by ID, avoiding linear searches.
When obtaining multiple users by IDs, only existing users in the dictionary are filtered and selected, optimizing the query.
4. Summary of Changes
Strict validations on input data.
Robust error handling with try-catch in all endpoints.
Use of efficient data structures (Dictionary<int, Usuario>) to improve performance.
Clear and appropriate HTTP responses according to the result of each operation.

For the creation of the remaining middleware, Copilot considered the following instructions:
-  Based on the generated code, implement middleware that logs the consulted methods, the path of the requested routes, and the returned response status code, all for auditing purposes.
-  Also generate another middleware for error handling where it captures unhandled exceptions and returns an error response in JSON format, for example { "error": "Internal server error." }
-  And add an authentication middleware that validates the tokens of incoming requests, allows access only to users with valid tokens, and returns 401 unauthorized for invalid tokens.

Copilot's comments were: 
Documentation of the Middleware Creation Process
1. Auditing Middleware
Motivation:
Log relevant information from each request for auditing and traceability purposes, such as the HTTP method, the requested path, and the response status code.

Implementation:

The AuditoriaMiddleware class was created.
This middleware intercepts each request, captures the method (GET, POST, etc.), the path (/users, /users/{id}), and after executing the next middleware or endpoint, obtains the response status code.
It uses ASP.NET Core's logging system (ILogger) to record this information.
The middleware is registered in the application's pipeline before the endpoints to ensure that all requests are audited.
Example log:

2. Global Error Handling Middleware
Motivation:
Capture all unhandled exceptions that may occur during the processing of a request and return a uniform and user-friendly response to the client.

Implementation:

The ErrorHandlerMiddleware class was created.
This middleware wraps the execution of the following components in a try-catch block.
If an exception occurs, it logs the error and responds with an HTTP 500 (Internal Server Error) code and a standard JSON message:
It is recommended to place this middleware at the beginning of the pipeline to capture any exception from subsequent middleware or endpoints.
3. Authentication Middleware
Motivation:
Protect API resources by allowing access only to requests authenticated with a valid token.

Implementation:

The AuthMiddleware class was created.
This middleware checks for the presence and validity of the Authorization header in each request.
If the token is valid (for example, "Bearer mi_token_secreto"), it allows access to the next middleware or endpoint.
If the token is invalid or missing, it responds with an HTTP 401 (Unauthorized) code and a JSON message:
This middleware should go after the error handler and before the endpoints to ensure the protection of all resources.